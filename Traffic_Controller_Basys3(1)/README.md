This code implements a basic traffic light controller using Verilog modules. Here's a breakdown of each module and how they work together:

**1. `oneHz_gen`:**

* It generates a 1Hz clock signal from a 100MHz input clock.

**2. `sw_debounce`:**

* This module is designed to debounce a button press.
* It uses three flip-flops (`t0`, `t1`, `t2`) to synchronize the button signal with the clock and eliminate any bouncing or glitches that might occur when a button is physically pressed or released.
* The output (`btn_out`) provides a stable and reliable button press signal after debouncing.

**3. `state_machine`:**

* This module is the core of the traffic light controller.
* It defines four states representing different traffic light phases:
    * `main_green_cross_red`: Main road has green light, cross road has red light (initial state)
    * `main_yellow_cross_red`: Main road has yellow light (transition)
    * `main_red_cross_green`: Main road has red light, cross road has green light
    * `main_red_cross_yellow`: Main road has red light (transition)
* It uses a 2-bit register (`state_reg`) to store the current state.
* It has a 5-bit counter (`light_counter`) to keep track of time for each light phase. (e.g., 15 seconds for main green, 3 seconds for yellow transitions)
* The `always @(posedge clk_1Hz or posedge reset)` block handles state transitions based on the current state and the counter value.
    * When the counter reaches a specific value for each phase, the state transitions to the next phase.
    * Upon reset, the state is set back to `main_green_cross_red`.
* Another `always @(posedge clk_1Hz)` block assigns the appropriate LED outputs (`main_st` and `cross_st`) based on the current state.
    * Each state combination defines which lights (red, yellow, green) are on for the main road and cross road.

**4. `traffic_controller`:**

* This is the top-level module that connects everything together.
* It takes the 100MHz clock and reset signal as inputs.
* It uses a debounced reset signal (`w_reset`) generated by the `sw_debounce` module to ensure a clean reset when the button is pressed.
* It instantiates the other three modules (`state_machine`, `oneHz_gen`, `sw_debounce`) and connects them appropriately.
* The `state_machine` module outputs the light patterns (`main_st` and `cross_st`) that are connected to the LED outputs of the traffic controller.

In summary, this code design creates a traffic light controller that cycles through different light phases (main green, main yellow, cross green, cross yellow) with specific timing controlled by the 1Hz clock signal. The debounce circuit ensures reliable button press detection for resetting the controller.

### How the Traffic Controller Works

The traffic controller is designed to manage the traffic lights at an intersection with one main road and one crossroad. It cycles through the traffic lights in a specific sequence to ensure smooth traffic flow and safety. Here's a high-level overview without diving into the technical details:

1. **Traffic Light States**: The system manages the states of traffic lights for both the main road and the crossroad. Each light can be green, yellow, or red.

2. **Timing Sequence**: The lights change according to a set timing sequence:
   - The main road light stays green for 15 seconds, then turns yellow for 3 seconds, and finally red.
   - The crossroad light stays red while the main road is green and yellow, then turns green when the main road is red. After 10 seconds, it turns yellow for 3 seconds before going back to red.
   
3. **State Machine**: The system uses a state machine to manage the sequence of light changes. The states change based on a timer.

4. **1Hz Clock Generator**: Since the FPGA clock runs much faster than what we need, a 1Hz clock is generated to slow down the clock to match the timing requirements for the traffic lights.

5. **Button Debounce**: A debounce mechanism ensures that the button press (used for resetting the system) is registered correctly without errors due to mechanical bouncing of the button.