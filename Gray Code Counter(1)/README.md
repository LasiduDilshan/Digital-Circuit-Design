**1. `sim_gray`:**

* This module simulates a Gray counter.
* It has a clock (`clk`) and a reset (`reset`) signal.
* It uses a separate module (`gray_counter`) to generate both the binary count (`o_bin`) and the corresponding Gray code (`o_gray_code`).
* The main module (`sim_gray`) generates a clock signal that toggles every nanosecond (`always #1 clk = ~clk;`).
* Initially, it sets `reset` high for 2 nanoseconds to clear the counter and then lets it run for 20 nanoseconds before stopping the simulation (`$finish`).

**2. `oneHz_gen`:**

* This module generates a 1Hz (one pulse per second) clock signal from a 100MHz clock input (`clk_100MHz`).
* It uses two registers:
    * `r_1Hz`: Stores the current state of the 1Hz clock (high or low).
    * `r_counter`: Counts up to a specific value (49,999,999 in this case).
* On every positive edge of the 100MHz clock (`always @(posedge clk_100MHz)`):
    * If the counter reaches its maximum value, it resets to 0 and flips the state of `r_1Hz`.
    * Otherwise, the counter increments.
* The output `clk_1Hz` is simply the current value of `r_1Hz`.

**3. `gray_counter`:**

* This module is a 3-bit binary counter with an additional output for the corresponding Gray code.
* It has a clock (`clk`), a reset (`reset`), a binary output (`o_bin`), and a Gray code output (`o_gray_code`).
* A binary counter is implemented using a 3-bit register (`bin_counter`) that increments on every positive edge of the clock or reset. The binary value is directly assigned to `o_bin`.
* There are two commented-out sections for generating the Gray code:
    * **Hard Coding:** This approach uses a case statement to assign a specific Gray code value based on the binary counter value.
    * **Combinational Logic:** This approach uses XOR gates to directly calculate the Gray code from the binary counter bits. The commented section shows how each Gray code bit is derived from the binary counter bits.

**4. `top`:**

* This module is the top-level module that connects the other modules.
* It takes a 100MHz clock (`clk_100MHz`) and a reset (`reset`) signal as inputs.
* It outputs both the binary count (`o_bin`) and the Gray code (`o_gray_code`).
* It instantiates two other modules:
    * `gray_counter`: This generates the binary and Gray code outputs based on a clock signal.
    * `oneHz_gen`: This generates a 1Hz clock signal from the 100MHz input.
* It connects the 1Hz clock (`w_1Hz`) generated by `oneHz_gen` to the `gray_counter` module as the clock input.

In summary, these modules demonstrate how to create a Gray counter driven by a slow clock signal (1Hz) derived from a high-frequency clock (100MHz). The `gray_counter` module provides the functionality of both a binary counter and its corresponding Gray code. 



Reference: https://www.eetimes.com/gray-code-fundamentals-part-2/

![5](https://github.com/LasiduDilshan/Digital-Circuit-Design/assets/126545632/eb401f14-7e1d-4c60-9f97-235fae68c004)
<img width="302" alt="6" src="https://github.com/LasiduDilshan/Digital-Circuit-Design/assets/126545632/b9a48b23-1cc5-4592-acbc-21cb0df3318e">
